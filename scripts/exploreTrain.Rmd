## Explore `train`

Take a sample for exploration.

```{r}
sample <- filter(train, id %in% sample(train$id, length(train$id) * 0.05))
```

Plot the density of the `loss` variable.

```{r}
summary(sample$loss)
ggplot(sample, aes(x = loss)) +
  geom_density() +
  scale_x_log10() +
  theme_bw()
```

Plot bivariate densities between `loss` and the `cont` variables.

```{r}
select(sample, matches("id|loss|cont")) %>%
  melt(id.vars = c("id", "loss")) %>%
  ggplot(aes(x = value, y = loss, group = variable)) +
    scale_y_log10() +
    stat_density_2d(aes(fill = ..level..), geom = "polygon") +
    scale_fill_gradient("density", low = "blue", high = "white") +
    facet_wrap(~ variable) +
    theme_bw()
```

Show summary statistics for `cont` variables.

```{r}
select(sample, matches("cont")) %>% summary()
```

The `cont` variables are pre-scaled with values between `r paste(select(sample, matches("cont")) %>% range(), collapse = ", ") %>% sprintf("(%s)")`.
Therefore, no preprocessing is needed.

Plot violin plots for `loss` and the `cat` variables.
*This isn't going to work well; there are too many possible values.*

```{r}
select(sample, matches("cat")) %>%
  melt(id.vars = NULL) %>%
  select(matches("value")) %>%
  unique() %>%
  nrow()
```

Check for near-zero variance among the `cat` and `cont` variables.
Exclude these near-zero variances; they likely will not contribute much to prediction.
*May revisit later.*

```{r}
nearzero <- 
  select(sample, matches("cat|cont")) %>%
    nearZeroVar(saveMetrics = TRUE) %>%
    transform(rowname = rownames(.)) %>%
    filter(zeroVar | nzv)
nearzero
```

Check how many unique values are in the remaining non-near-zero variance `cat` variables.
*There are still too many possible values.*

```{r}
select(sample, -matches(paste(c(as.character(nearzero$rowname), "cont", "id", "loss"), collapse = "|"))) %>%
  melt(id.vars = NULL) %>%
  select(matches("value")) %>%
  unique() %>%
  nrow()
```
